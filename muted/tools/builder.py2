
from __future__ import annotations

from typing import List
from typing import NamedTuple
from typing import Optional
from typing import Tuple

from pathlib import Path

from random import randint

import json

from component.text_component import TextComponent

from entity.entity import Entity

from tools.grid import Block
from tools.grid import Grid
from tools.node import Node
from tools.vertex import Vertex

TEXT_COMPONENT = (
    'room',
    'exit'
)

class Seeking(NamedTuple):
    start: int
    fixed: int
    step: int
    vertical: bool

class Zone:
    BLOCK: str = ' '
    STREET: str = '.'
    BLACKSMITH: str = 'S'
    HERBAL_SHOP: str = 'H'
    GROCERY_STORE: str = 'G'
    CLOTHING_STORE: str = 'C'
    INN: str = 'I'
    PAWN_SHOP: str = 'P'
    TAVERN: str = 'T'
    BANK: str = 'B'
    T_SHAPE: str = '-'
    CROSS: str = '+'
    NORTH: str = '^'
    SOUTH: str = 'v'
    EAST: str = '>'
    WEST: str = '<'

    BUILDING: Tuple[Block] = (
        Block.BANK,
        Block.BLACKSMITH,
        Block.CLOTHING_STORE,
        Block.GROCERY_STORE,
        Block.HERBAL_SHOP,
        Block.INN,
        Block.PAWN_SHOP,
        Block.TAVERN
    )

    GROUND: Tuple[Block] = (
        Block.BLOCK,
        Block.CROSS,
        Block.STREET,
        Block.T_SHAPE
    )

    PAVEMENT: Tuple[Block] = (
        Block.STREET,
        Block.CROSS,
        Block.T_SHAPE
    )

    TAG: Map[str, str] = {
        '.': 'street',
        '+': 'cross',
        '-': 't_shape',
        'S': 'blacksmith',
        'G': 'grocery_store',
        'C': 'clothing_store',
        'I': 'inn',
        'B': 'bank',
        'P': 'pawn_shop',
        'T': 'tavern',
        'H': 'herbal_store'
    }

    def __init__(self, width: int, height: int):
        self._map = Grid(width, height)

        self._axis_x: Tuple[int, int] = (
            int(width * .33),
            int(width * .67)
        )

        self._axis_y: Tuple[int, int] = (
            int(height * .33),
            int(height * .67)
        )

        self._components: Mapping[str, Type[Component]] = {}

        for component in TEXT_COMPONENT:
            self._components[component] = TextComponent.instance(component)

        self._entity_component = TextComponent.instance('entity')

        self._buildings: List[Node] = []
        self._facing: List[str] = []
        self._pavements: List[Vertex] = []

        self._fix_housing()
#        self._fix_street()
#        self._fix_road()
#        self._fix_junction()

    def find(self, src: Node, dst: Node) -> Sequence[Vertex]:
        openned: List[Node] = [ src ]
        closed: List[Node] = []

        while openned:
            node: Node = openned[0]
            index: int = 0

            for idx, current in enumerate(openned):
                if current.f < node.f:
                    node = current
                    index = idx

            openned.pop(index)
            closed.append(node)

            if node == dst:
                path: List[Vertex] = []
                current: Optional[Node] = node

                while current:
                    path.append(Vertex(current.x, current.y))
                    current = current.parent

                return path[::-1] # Return reversed path

            for node in self._child_list(node):
                if self._has_visited(node, closed):
                    continue

                for current in openned:
                    if current == node and current.g >= node.g:
                        break
                else:
                    node.h = (
                        ((node.x - dst.x) ** 2) +
                        ((node.y - dst.y) ** 2)
                    )

                    openned.append(node)

    def _has_visited(self, node: Node, node_list: List[Node]) -> bool:
        visited: bool = True

        for current in node_list:
            if current == node:
                break
        else:
            visited = False

        return visited

    def _child_list(self, node: Node) -> Sequence[Node]:
        child_list: List[Node] = []

        for x_step, y_step in ((0, -1), (-1, 0), (0, 1), (1, 0)):
            x = node.x + x_step
            y = node.y + y_step

            if (
                x < 0 or
                x >= self._map.width or
                y < 0 or
                y >= self._map.height
            ):
                continue

            if not self._map.cell(x, y) in Zone.GROUND:
                continue

            child_list.append(Node(node, x, y))

        return child_list

    def _seek_nonblock(self, seek: Seeking) -> int:
        index = seek.start

        try:
            if seek.vertical:
                while self._map[index][seek.fixed] == Zone.BLOCK:
                    index += seek.step
            else:
                while self._map[seek.fixed][index] == Zone.BLOCK:
                    index += seek.step
        except IndexError:
            pass

        return index

    def _count_links(self, vertex: Vertex) -> int:
        counts = 0

        for x, y in ((0, -1), (-1, 0), (0, 1), (1, 0)):
            try:
                if self._map[vertex.y + y][vertex.x + x] in Zone.PAVEMENT:
                    counts += 1
            except IndexError:
                pass

        return counts

    def _fix_housing(self):
        for i in range(0, len(Zone.BUILDING)):
            x = randint(
                int(self._map.width * .20), int(self._map.width * .80)
            )
            y = randint(
                int(self._map.height * .20), int(self._map.height * .80)
            )

            while (
                (not self._map.cell(x, y) == Block.BLOCK) or
                (x in self._axis_x) or
                (y in self._axis_y)
            ):
                x = randint(
                    int(self._map.width * .20), int(self._map.width * .80)
                )
                y = randint(
                    int(self._map.height * .20), int(self._map.height * .80)
                )

            self._map.update(x, y, Zone.BUILDING[i])

            self._buildings.append(Node(Vertex(x, y)))

    def _fix_junction(self) -> None:
        for vertex in self._pavements:
            counts = self._count_links(vertex)

            if 4 == counts:
                self._map[vertex.y][vertex.x] = Zone.CROSS
            elif 3 == counts:
                self._map[vertex.y][vertex.x] = Zone.T_SHAPE

    def _fix_line(self, src: Vertex, dst: Vertex) -> None:
        if src.x == dst.x:
            for y in range(src.y, dst.y):
                self._map[y][src.x] = Zone.STREET
                self._pavements.append(Vertex(src.x, y))
        else:
            for x in range(src.x, dst.x):
                self._map[src.y][x] = Zone.STREET
                self._pavements.append(Vertex(x, src.y))

    def _fix_path(self, path: List[Vectex]) -> None:
        for x, y in path:
            self._map[y][x] = Zone.STREET
            self._pavements.append(Vertex(x, y))

    def _fix_road(self) -> None:
        r = randint(0, 1)

        x = self._axis_x[r]
        y = min(
            self._seek_nonblock(Seeking(0, x, 1, True)),
            randint(int(self._height * .20), int(self._height * .25))
        )

        self._fix_line(Vertex(x, y), Vertex(x, self._height))

        x = self._axis_x[1 - r]
        y = max(
            self._seek_nonblock(Seeking(self._height - 1, x, -1, True)),
            randint(int(self._height * .75), int(self._height * .80))
        )

        self._fix_line(Vertex(x, 0), Vertex(x, y + 1))

        r = randint(0, 1)

        y = self._axis_y[r]
        x = min(
            self._seek_nonblock(Seeking(0, y, 1, False)),
            randint(int(self._width * .20), int(self._width * .25))
        )

        self._fix_line(Vertex(x, y), Vertex(self._width, y))

        y = self._axis_y[1 - r]
        x = max(
            self._seek_nonblock(Seeking(self._width - 1, y, -1, False)),
            randint(int(self._width * .75), int(self._width * .80))
        )

        self._fix_line(Vertex(0, y), Vertex(x + 1, y))

    def _fix_street(self):
        for src in self._buildings:
            pathes = [
                self.find(src, dst)
                for dst in (
                    Node(Vertex(src.x, self._axis_y[0])),
                    Node(Vertex(src.x, self._axis_y[1])),
                    Node(Vertex(self._axis_x[0], src.y)),
                    Node(Vertex(self._axis_x[1], src.y))
                )
            ]

            cost = len(pathes[0])
            index = 0

            for i, path in enumerate(pathes):
                if len(path) < cost:
                    cost = len(path)
                    index = i
                elif len(path) == cost:
                    index = index if randint(0, 1) else i

            self._fix_path(pathes[index][1:])

            if index < 2:
                if src.y < self._axis_y[index]:
                    self._facing.append(Zone.SOUTH)
                else:
                    self._facing.append(Zone.NORTH)
            else:
                if src.x < self._axis_x[index - 2]:
                    self._facing.append(Zone.EAST)
                else:
                    self._facing.append(Zone.WEST)

    def publish(self) -> None:
        cache: Mapping[str, str] = {}
        room_component = self._components['room']
        exit_component = self._components['exit']

        for n in (*self._buildings, *self._pavements):
            entity = Entity.eid()
            cache[f'{n.x}x{n.y}'] = entity
            room_component.update(
                entity,
                self._entity_component.text(
                    self._map.cell(n.x, n.y).name.lower()
                )
            )

        for v in self._pavements:
            exits = {}

            for i, vec in enumerate((
                Vertex(0, -1), Vertex(-1, 0), Vertex(0, 1), Vertex(1, 0)
            )):
                x = v.x + vec.x
                y = v.y + vec.y

                if (
                    x < 0 or
                    x >= self._width or
                    y < 0 or
                    y >= self._height
                ):
                    continue

                if self._map.cell(x, y) == Block.BLOCK:
                    continue

                exits['nwse'[i]] = cache[f'{x}x{y}']

            exit_component.update(cache[f'{v.x}x{v.y}'], exits)

        for i, n in enumerate(self._buildings):
            room = cache[f'{n.x}x{n.y}']

#            if self._facing[i] == '^':
#                exit_component.update(
#                    room,
#                    { 'n': cache[f'{n.x}x{n.y - 1}'] }
                #)
#            elif self._facing[i] == '<':
#                exit_component.update(
#                    room,
#                    { 'w': cache[f'{n.x - 1}x{n.y}'] }
#                )
#            elif self._facing[i] == 'v':
#                exit_component.update(
#                    room,
#                    { 's': cache[f'{n.x}x{n.y + 1}'] }
#                )
#            elif self._facing[i] == '>':
#                exit_component.update(
#0                    room,
#                    { 'e': cache[f'{n.x + 1}x{n.y}'] }
#                )
#            else:
#                print(f'Panic! Facing error!')

#        for key, value in self._components.items():
#            value.save(key)

    def mini_map(self) -> str:
        return '\n'.join([ ' '.join(street) for street in self._map ])

    def __repr__(self) -> str:
        return '\n'.join([ ' '.join(street) for street in self._map ])

if __name__ == '__main__':
    zone = Zone(27, 17)
    zone.publish()

    print(zone.mini_map())

# builder.py
